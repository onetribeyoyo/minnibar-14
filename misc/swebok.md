
# SWEBOK #

<https://www.computer.org/education/bodies-of-knowledge/software-engineering/topics>

------

## Chapter Summary ##

- Chapter 1: Software Requirements
- Chapter 2: Software Design
- Chapter 3: Software Construction
- Chapter 4: Software Testing
- Chapter 5: Software Maintenance
- Chapter 6: Software Configuration Management
- Chapter 7: Software Engineering Management
- Chapter 8: Software Engineering Process
- Chapter 9: Software Engineering Models and Methods
- Chapter 10: Software Quality
- Chapter 11: Software Engineering Professional Practice
- Chapter 12: Software Engineering Economics
- Chapter 13: Computing Foundations
- Chapter 14: Mathematical Foundations
- Chapter 15: Engineering Foundations

------

## Section Summary ##

### Chapter 1: Software Requirements ###

1. Software Requirements Fundamentals &#10003;
2. Requirements Process &#10003;
3. Requirements Elicitation &#10003;
4. Requirements Analysis &#10003;
5. Requirements Specification &#10003;
6. Requirements Validation &#10003;
7. Practical Considerations &#10003;
8. Software Requirements Tools &#10003;

### Chapter 2: Software Design ###

1. Software Design Fundamentals &#10003;
2. Key Issues in Software Design &#10003;
3. Software Structure and Architecture &#10003;
4. User Interface Design &#10003;
5. Software Design Quality Analysis and Evaluation &#10003;
6. Software Design Notations &#10003;
7. Software Design Strategies and Methods &#10003;
8. Software Design Tools &#10003;

### Chapter 3: Software Construction ###

1. Software Construction Fundamentals &#10003;
2. Managing Construction &#10003;
3. Practical Considerations &#10003;
4. Construction Technologies &#10003;
5. Software Construction Tools &#10003;

### Chapter 4: Software Testing ###

1. Software Testing Fundamentals &#10003;
2. Test Levels &#10003;
3. Test Techniques &#10003;
4. Test-Related Measures &#10003;
5. Test Process &#10003;
6. Software Testing Tools &#10003;

### Chapter 5: Software Maintenance ###

1. Software Maintenance Fundamentals
2. Key Issues in Software Maintenance
3. Maintenance Process
4. Techniques for Maintenance
5. Software Maintenance Tools

### Chapter 6: Software Configuration Management ###

1. Management of the SCM Process &#10003;
2. Software Configuration Identification &#10003;
3. Software Configuration Control &#10003;
4. Software Configuration Status Accounting &#10003;
5. Software Configuration Auditing &#10003;
6. Software Release Management and Delivery &#10003;
7. Software Configuration Management Tools &#10003;

### Chapter 7: Software Engineering Management ###

1. Initiation and Scope Definition &#10003;
2. Software Project Planning &#10003;
3. Software Project Enactment &#10003;
4. Review and Evaluation &#10003;
5. Closure &#10003;
6. Software Engineering Measurement
7. Software Engineering Management Tools

### Chapter 8: Software Engineering Process ###

1. Software Process Definition &#10003;
2. Software Life Cycles &#10003;
3. Software Process Assessment and Improvement &#10003;
4. Software Measurement &#10003;
5. Software Engineering Process Tools

### Chapter 9: Software Engineering Models and Methods ###

1. Modeling &#10003;
2. Types of Models &#10003;
3. Analysis of Models &#10003;
4. Software Engineering Methods &#10003;

### Chapter 10: Software Quality ###

1. Software Quality Fundamentals &#10003;
2. Software Quality Management Processes
3. Practical Considerations
4. Software Quality Tools

### Chapter 11: Software Engineering Professional Practice ###

1. Professionalism
2. Group Dynamics and Psychology
3. Communication Skills &#10003;

### Chapter 12: Software Engineering Economics ###

1. Software Engineering Economics Fundamentals
2. Life Cycle Economics
3. Risk and Uncertainty &#10003;
4. Economic Analysis Methods
5. Practical Considerations

### Chapter 13: Computing Foundations ###

1. Problem Solving Techniques &#10003;
2. Abstraction &#10003;
3. Programming Fundamentals &#10003;
4. Programming Language Basics &#10003;
5. Debugging Tools and Techniques &#10003;
6. Data Structure and Representation &#10003;
7. Algorithms and Complexity &#10003;
8. Basic Concept of a System &#10003;
9. Computer Organization &#10003;
10. Compiler Basics &#10003;
11. Operating Systems Basics &#10003;
12. Database Basics and Data Management &#10003;
13. Network Communication Basics &#10003;
14. Parallel and Distributed Computing &#10003;
15. Basic User Human Factors &#10003;
16. Basic Developer Human Factors &#10003;
17. Secure Software Development and Maintenance &#10003;

### Chapter 14: Mathematical Foundations ###

1. Set, Relations, Functions &#10003;
2. Basic Logic &#10003;
3. Proof Techniques &#10003;
4. Basics of Counting &#10003;
5. Graphs and Trees &#10003;
6. Discrete Probability &#10003;
7. Finite State Machines &#10003;
8. Grammars &#10003;
9. Numerical Precision, Accuracy, and Errors &#10003;
10. Number Theory &#10003;
11. Algebraic Structures &#10003;

### Chapter 15: Engineering Foundations ###

1. Empirical Methods and Experimental Techniques &#10003;
2. Statistical Analysis &#10003;
3. Measurement &#10003;
4. Engineering Design &#10003;
5. Modeling, Simulation, and Prototyping &#10003;
6. Standards &#10003;
7. Root Cause Analysis &#10003;


------


## Chapter 1: Software Requirements ##

### 1. Software Requirements Fundamentals ###

1.1. Definition of a Software Requirement <br />
1.2. Product and Process Requirements <br />
1.3. Functional and Nonfunctional Requirements <br />
1.4. Emergent Properties <br />
1.5. Quantifiable Requirements <br />
1.6. System Requirements and Software Requirements <br />

### 2. Requirements Process ###

2.1. Process Models <br />
2.2. Process Actors <br />
2.3. Process Support and Management <br />
2.4. Process Quality and Improvement <br />

### 3. Requirements Elicitation ###

3.1. Requirements Sources <br />
3.2. Elicitation Techniques <br />

### 4. Requirements Analysis ###

4.1. Requirements Classification <br />
4.2. Conceptual Modeling <br />
4.3. Architectural Design and Requirements Allocation <br />
4.4. Requirements Negotiation <br />
4.5. Formal Analysis <br />

### 5. Requirements Specification ###

5.1. System Definition Document <br />
5.2. System Requirements Specification <br />
5.3. Software Requirements Specification <br />

### 6. Requirements Validation ###

6.1. Requirements Reviews <br />
6.2. Prototyping <br />
6.3. Model Validation <br />
6.4. Acceptance Tests <br />

### 7. Practical Considerations ###

7.1. Iterative Nature of the Requirements Process <br />
7.2. Change Management <br />
7.3. Requirements Attributes <br />
7.4. Requirements Tracing <br />
7.5. Measuring Requirements <br />

### 8. Software Requirements Tools ###

## Chapter 2: Software Design ##

### 1. Software Design Fundamentals ###

1.1. General Design Concepts <br />
1.2. Context of Software Design <br />
1.3. Software Design Process <br />
1.4. Software Design Principles <br />

### 2. Key Issues in Software Design ###

2.1. Concurrency <br />
2.2. Control and Handling of Events <br />
2.3. Data Persistence <br />
2.4. Distribution of Components <br />
2.5. Error and Exception Handling and Fault Tolerance <br />
2.6. Interaction and Presentation <br />
2.7. Security <br />

### 3. Software Structure and Architecture ###

3.1. Architectural Structures and Viewpoints <br />
3.2. Architectural Styles <br />
3.3. Design Patterns <br />
3.4. Architecture Design Decisions <br />
3.5. Families of Programs and Frameworks <br />

### 4. User Interface Design ###

4.1. General User Interface Design Principles <br />
4.2. User Interface Design Issues <br />
4.3. The Design of User Interaction Modalities <br />
4.4. The Design of Information Presentation <br />
4.5. User Interface Design Process <br />
4.6. Localization and Internationalization <br />
4.7. Metaphors and Conceptual Models <br />

### 5. Software Design Quality Analysis and Evaluation ###

5.1. Quality Attributes <br />
5.2. Quality Analysis and Evaluation Techniques <br />
5.3. Measures <br />

### 6. Software Design Notations ###

6.1. Structural Descriptions (Static View) <br />
6.2. Behavioral Descriptions (Dynamic View) <br />

### 7. Software Design Strategies and Methods ###

7.1. General Strategies <br />
7.2. Function-Oriented (Structured) Design <br />
7.3. Object-Oriented Design <br />
7.4. Data Structure-Centered Design <br />
7.5. Component-Based Design (CBD) <br />
7.6. Other Methods <br />

### 8. Software Design Tools ###

## Chapter 3: Software Construction ##

### 1. Software Construction Fundamentals ###

1.1. Minimizing Complexity <br />
1.2. Anticipating Change <br />
1.3. Constructing for Verification <br />
1.4. Reuse <br />
1.5. Standards in Construction <br />

### 2. Managing Construction ###

2.1. Construction in Life Cycle Models <br />
2.2. Construction Planning <br />
2.3. Construction Measurement <br />

### 3. Practical Considerations ###

3.1. Construction Design <br />
3.2. Construction Languages <br />
3.3. Coding <br />
3.4. Construction Testing <br />
3.5. Construction for Reuse <br />
3.6. Construction with Reuse <br />
3.7. Construction Quality <br />
3.8. Integration <br />

### 4. Construction Technologies ###

4.1. API Design and Use <br />
4.2. Object-Oriented Runtime Issues <br />
4.3. Parameterization and Generics <br />
4.4. Assertions, Design by Contract, and Defensive Programming <br />
4.5. Error Handling, Exception Handling, and Fault Tolerance <br />
4.6. Executable Models <br />
4.7. State-Based and Table-Driven Construction Techniques <br />
4.8. Runtime Configuration and Internationalization <br />
4.9. Grammar-Based Input Processing <br />
4.10. Concurrency Primitives <br />
4.11. Middleware <br />
4.12. Construction Methods for Distributed Software <br />
4.13. Constructing Heterogeneous Systems <br />
4.14. Performance Analysis and Tuning <br />
4.15. Platform Standards <br />
4.16. Test-First Programming <br />

### 5. Software Construction Tools ###

5.1. Development Environments <br />
5.2. GUI Builders <br />
5.3. Unit Testing Tools <br />
5.4. Profiling, Performance Analysis, and Slicing Tools <br />

## Chapter 4: Software Testing ##

### 1. Software Testing Fundamentals ###

1.1. Testing-Related Terminology <br />
1.2. Key Issues <br />
1.3. Relationship of Testing to Other Activities <br />

### 2. Test Levels ###

2.1. The Target of the Test <br />
2.2. Objectives of Testing <br />

### 3. Test Techniques ###

3.1. Based on the Software Engineer's Intuition and Experience <br />
3.2. Input Domain-Based Techniques <br />
3.3. Code-Based Techniques <br />
3.4. Fault-Based Techniques <br />
3.5. Usage-Based Techniques <br />
3.6. Model-Based Testing Techniques <br />
3.7. Techniques Based on the Nature of the Application <br />
3.8. Selecting and Combining Techniques <br />

### 4. Test-Related Measures ###

4.1. Evaluation of the Program Under Test <br />
4.2. Evaluation of the Tests Performed <br />

### 5. Test Process ###

5.1. Practical Considerations <br />
5.2. Test Activities <br />

### 6. Software Testing Tools ###

6.1. Testing Tool Support <br />
6.2. Categories of Tools <br />

## Chapter 5: Software Maintenance ##

### 1. Software Maintenance Fundamentals ###

1.1. Definitions and Terminology <br />
1.2. Nature of Maintenance <br />
1.3. Need for Maintenance <br />
1.4. Majority of Maintenance Costs <br />
1.5. Evolution of Software <br />
1.6. Categories of Maintenance <br />

### 2. Key Issues in Software Maintenance ###

2.1. Technical Issues <br />
2.2. Management Issues <br />
2.3. Maintenance Cost Estimation <br />
2.4. Software Maintenance Measurement <br />

### 3. Maintenance Process ###

3.1. Maintenance Processes <br />
3.2. Maintenance Activities <br />

### 4. Techniques for Maintenance ###

4.1. Program Comprehension <br />
4.2. Reengineering <br />
4.3. Reverse Engineering <br />
4.4. Migration <br />
4.5. Retirement <br />

### 5. Software Maintenance Tools ###

## Chapter 6: Software Configuration Management ##

### 1. Management of the SCM Process ###

1.1. Organizational Context for SCM <br />
1.2. Constraints and Guidance for the SCM Process <br />
1.3. Planning for SCM <br />
1.4. SCM Plan <br />
1.5. Surveillance of Software Configuration Management <br />

### 2. Software Configuration Identification ###

2.1. Identifying Items to Be Controlled <br />
2.2. Software Library <br />

### 3. Software Configuration Control ###

3.1. Requesting, Evaluating, and Approving Software Changes <br />
3.2. Implementing Software Changes <br />
3.3. Deviations and Waivers <br />

### 4. Software Configuration Status Accounting ###

4.1. Software Configuration Status Information <br />
4.2. Software Configuration Status Reporting <br />

### 5. Software Configuration Auditing ###

5.1. Software Functional Configuration Audit <br />
5.2. Software Physical Configuration Audit <br />
5.3. In-Process Audits of a Software Baseline <br />

### 6. Software Release Management and Delivery ###

6.1. Software Building <br />
6.2. Software Release Management <br />

### 7. Software Configuration Management Tools ###

## Chapter 7: Software Engineering Management ##

### 1. Initiation and Scope Definition ###

1.1. Determination and Negotiation of Requirements <br />
1.2. Feasibility Analysis <br />
1.3. Process for the Review and Revision of Requirements <br />

### 2. Software Project Planning ###

2.1. Process Planning <br />
2.2. Determine Deliverables <br />
2.3. Effort, Schedule, and Cost Estimation <br />
2.4. Resource Allocation <br />
2.5. Risk Management <br />
2.6. Quality Management <br />
2.7. Plan Management <br />

### 3. Software Project Enactment ###

3.1. Implementation of Plans <br />
3.2. Software Acquisition and Supplier Contract Management <br />
3.3. Implementation of Measurement Process <br />
3.4. Monitor Process <br />
3.5. Control Process <br />
3.6. Reporting <br />

### 4. Review and Evaluation ###

4.1. Determining Satisfaction of Requirements <br />
4.2. Reviewing and Evaluating Performance <br />

### 5. Closure ###

5.1. Determining Closure <br />
5.2. Closure Activities <br />

### 6. Software Engineering Measurement ###

6.1. Establish and Sustain Measurement Commitment <br />
6.2. Plan the Measurement Process <br />
6.3. Perform the Measurement Process <br />
6.4. Evaluate Measurement <br />

### 7. Software Engineering Management Tools ###

## Chapter 8: Software Engineering Process ##

### 1. Software Process Definition ###

1.1. Software Process Management <br />
1.2. Software Process Infrastructure <br />

### 2. Software Life Cycles ###

2.1. Categories of Software Processes <br />
2.2. Software Life Cycle Models <br />
2.3. Software Process Adaptation <br />
2.4. Practical Considerations <br />

### 3. Software Process Assessment and Improvement ###

3.1. Software Process Assessment Models <br />
3.2. Software Process Assessment Methods <br />
3.3. Software Process Improvement Models <br />
3.4. Continuous and Staged Software Process Ratings <br />

### 4. Software Measurement ###

4.1. Software Process and Product Measurement <br />
4.2. Quality of Measurement Results <br />
4.3. Software Information Models <br />
4.4. Software Process Measurement Techniques <br />

### 5. Software Engineering Process Tools ###

## Chapter 9: Software Engineering Models and Methods ##

### 1. Modeling ###

1.1. Modeling Principles <br />
1.2. Properties and Expression of Models <br />
1.3. Syntax, Semantics, and Pragmatics <br />
1.4. Preconditions, Postconditions, and Invariants <br />

### 2. Types of Models ###

2.1. Information Modeling <br />
2.2. Behavioral Modeling <br />
2.3. Structure Modeling <br />

### 3. Analysis of Models ###

3.1. Analyzing for Completeness <br />
3.2. Analyzing for Consistency <br />
3.3. Analyzing for Correctness <br />
3.4. Traceability <br />
3.5. Interaction Analysis <br />

### 4. Software Engineering Methods ###

4.1. Heuristic Methods <br />
4.2. Formal Methods <br />
4.3. Prototyping Methods <br />
4.4. Agile Methods <br />

## Chapter 10: Software Quality ##

### 1. Software Quality Fundamentals ###

1.1. Software Engineering Culture and Ethics <br />
1.2. Value and Costs of Quality <br />
1.3. Models and Quality Characteristics <br />
1.4. Software Quality Improvement <br />
1.5. Software Safety <br />

### 2. Software Quality Management Processes ###

2.1. Software Quality Assurance <br />
2.2. Verification & Validation <br />
2.3. Reviews and Audits <br />

### 3. Practical Considerations ###

3.1. Software Quality Requirements <br />
3.2. Defect Characterization <br />
3.3. Software Quality Management Techniques <br />
3.4. Software Quality Measurement <br />

### 4. Software Quality Tools ###

## Chapter 11: Software Engineering Professional Practice ##

### 1. Professionalism ###

1.1. Accreditation, Certification, and Licensing <br />
1.2. Codes of Ethics and Professional Conduct <br />
1.3. Nature and Role of Professional Societies <br />
1.4. Nature and Role of Software Engineering Standards <br />
1.5. Economic Impact of Software <br />
1.6. Employment Contracts <br />
1.7. Legal Issues <br />
1.8. Documentation <br />
1.9. Tradeoff Analysis <br />

### 2. Group Dynamics and Psychology ###

2.1. Dynamics of Working in Teams/Groups <br />
2.2. Individual Cognition <br />
2.3. Dealing with Problem Complexity <br />
2.4. Interacting with Stakeholders <br />
2.5. Dealing with Uncertainty and Ambiguity <br />
2.6. Dealing with Multicultural Environments <br />

### 3. Communication Skills ###

3.1. Reading, Understanding, and Summarizing <br />
3.2. Writing <br />
3.3. Team and Group Communication <br />
3.4. Presentation Skills <br />

## Chapter 12: Software Engineering Economics ##

### 1. Software Engineering Economics Fundamentals ###

1.1. Finance <br />
1.2. Accounting <br />
1.3. Controlling <br />
1.4. Cash Flow <br />
1.5. Decision-Making Process <br />
1.6. Valuation <br />
1.7. Inflation <br />
1.8. Depreciation <br />
1.9. Taxation <br />
1.10. Time-Value of Money <br />
1.11. Efficiency <br />
1.12. Effectiveness <br />
1.13. Productivity <br />

### 2. Life Cycle Economics ###

2.1. Product <br />
2.2. Project <br />
2.3. Program <br />
2.4. Portfolio <br />
2.5. Product Life Cycle <br />
2.6. Project Life Cycle <br />
2.7. Proposals <br />
2.8. Investment Decisions <br />
2.9. Planning Horizon <br />
2.10. Price and Pricing <br />
2.11. Cost and Costing <br />
2.12. Performance Measurement <br />
2.13. Earned Value Management <br />
2.14. Termination Decisions <br />
2.15. Replacement and Retirement Decisions <br />

### 3. Risk and Uncertainty ###

3.1. Goals, Estimates, and Plans <br />
3.2. Estimation Techniques <br />
3.3. Addressing Uncertainty <br />
3.4. Prioritization <br />
3.5. Decisions under Risk <br />
3.6. Decisions under Uncertainty <br />

### 4. Economic Analysis Methods ###

4.1. For-Profit Decision Analysis <br />
4.2. Minimum Acceptable Rate of Return <br />
4.3. Return on Investment <br />
4.4. Return on Capital Employed <br />
4.5. Cost-Benefit Analysis <br />
4.6. Cost-Effectiveness Analysis <br />
4.7. Break-Even Analysis <br />
4.8. Business Case <br />
4.9. Multiple Attribute Evaluation <br />
4.10. Optimization Analysis <br />

### 5. Practical Considerations ###

5.1. The "Good Enough" Principle <br />
5.2. Friction-Free Economy <br />
5.3. Ecosystems <br />
5.4. Offshoring and Outsourcing <br />

## Chapter 13: Computing Foundations ##

### 1. Problem Solving Techniques ###

1.1. Definition of Problem Solving <br />
1.2. Formulating the Real Problem <br />
1.3. Analyze the Problem <br />
1.4. Design a Solution Search Strategy <br />
1.5. Problem Solving Using Programs <br />

### 2. Abstraction ###

2.1. Levels of Abstraction <br />
2.2. Encapsulation <br />
2.3. Hierarchy <br />
2.4. Alternate Abstractions <br />

### 3. Programming Fundamentals ###

3.1. The Programming Process <br />
3.2. Programming Paradigms <br />

### 4. Programming Language Basics ###

4.1. Programming Language Overview <br />
4.2. Syntax and Semantics of Programming Languages <br />
4.3. Low-Level Programming Languages <br />
4.4. High-Level Programming Languages <br />
4.5. Declarative vs. Imperative Programming Languages <br />

### 5. Debugging Tools and Techniques ###

5.1. Types of Errors <br />
5.2. Debugging Techniques <br />
5.3. Debugging Tools <br />

### 6. Data Structure and Representation ###

6.1. Data Structure Overview <br />
6.2. Types of Data Structure <br />
6.3. Operations on Data Structures <br />

### 7. Algorithms and Complexity ###

7.1. Overview of Algorithms <br />
7.2. Attributes of Algorithms <br />
7.3. Algorithmic Analysis <br />
7.4. Algorithmic Design Strategies <br />
7.5. Algorithmic Analysis Strategies <br />

### 8. Basic Concept of a System ###

8.1. Emergent System Properties <br />
8.2. Systems Engineering <br />
8.3. Overview of a Computer System <br />

### 9. Computer Organization ###

9.1. Computer Organization Overview <br />
9.2. Digital Systems <br />
9.3. Digital Logic <br />
9.4. Computer Expression of Data <br />
9.5. The Central Processing Unit (CPU) <br />
9.6. Memory System Organization <br />
9.7. Input and Output (I/O) <br />

### 10. Compiler Basics ###

10.1. Compiler/Interpreter Overview <br />
10.2. Interpretation and Compilation <br />
10.3. The Compilation Process <br />

### 11. Operating Systems Basics ###

11.1. Operating Systems Overview <br />
11.2. Tasks of an Operating System <br />
11.3. Operating System Abstractions <br />
11.4. Operating Systems Classification <br />

### 12. Database Basics and Data Management ###

12.1. Entity and Schema <br />
12.2. Database Management Systems (DBMS) <br />
12.3. Database Query Language <br />
12.4. Tasks of DBMS Packages <br />
12.5. Data Management <br />
12.6. Data Mining <br />

### 13. Network Communication Basics ###

13.1. Types of Network <br />
13.2. Basic Network Components <br />
13.3. Networking Protocols and Standards <br />
13.4. The Internet <br />
13.5. Internet of Things <br />
13.6. Virtual Private Network (VPN) <br />

### 14. Parallel and Distributed Computing ###

14.1. Parallel and Distributed Computing Overview <br />
14.2. Difference between Parallel and Distributed Computing <br />
14.3. Parallel and Distributed Computing Models <br />
14.4. Main Issues in Distributed Computing <br />

### 15. Basic User Human Factors ###

15.1. Input and Output <br />
15.2. Error Messages <br />
15.3. Software Robustness <br />

### 16. Basic Developer Human Factors ###

16.1. Structure <br />
16.2. Comments <br />

### 17. Secure Software Development and Maintenance ###

17.1. Software Requirements Security <br />
17.2. Software Design Security <br />
17.3. Software Construction Security <br />
17.4. Software Testing Security <br />
17.5. Build Security into Software Engineering Process <br />
17.6. Software Security Guidelines <br />

## Chapter 14: Mathematical Foundations ##

### 1. Set, Relations, Functions ###

1.1. Set Operations <br />
1.2. Properties of Set <br />
1.3. Relation and Function <br />

### 2. Basic Logic ###

2.1. Propositional Logic <br />
2.2. Predicate Logic <br />

### 3. Proof Techniques ###

3.1. Methods of Proving Theorems <br />

### 4. Basics of Counting ###

### 5. Graphs and Trees ###

5.1. Graphs <br />
5.2. Trees <br />

### 6. Discrete Probability ###

### 7. Finite State Machines ###

### 8. Grammars ###

8.1. Language Recognition <br />

### 9. Numerical Precision, Accuracy, and Errors ###

### 10. Number Theory ###

10.1. Divisibility <br />
10.2. Prime Number, GCD <br />

### 11. Algebraic Structures ###

11.1. Group <br />
11.2. Rings <br />

## Chapter 15: Engineering Foundations ##

### 1. Empirical Methods and Experimental Techniques ###

1.1. Designed Experiment <br />
1.2. Observational Study <br />
1.3. Retrospective Study <br />

### 2. Statistical Analysis ###

2.1. Unit of Analysis (Sampling Units), Population, and Sample <br />
2.2. Concepts of Correlation and Regression <br />

### 3. Measurement ###

3.1. Levels (Scales) of Measurement <br />
3.2. Direct and Derived Measures <br />
3.3. Reliability and Validity <br />
3.4. Assessing Reliability <br />

### 4. Engineering Design ###

4.1. Engineering Design in Engineering Education <br />
4.2. Design as a Problem Solving Activity <br />
4.3. Steps Involved in Engineering Design <br />

### 5. Modeling, Simulation, and Prototyping ###

5.1. Modeling <br />
5.2. Simulation <br />
5.3. Prototyping <br />

### 6. Standards ###

### 7. Root Cause Analysis ###

7.1. Techniques for Conducting Root Cause Analysis <br />
